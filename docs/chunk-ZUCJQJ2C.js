import{b as g}from"./chunk-4W7WESQ7.js";import{T as i,X as n,f as h,g as f}from"./chunk-DUPXJZ6A.js";import{c as o}from"./chunk-AH3KB6OD.js";var d=class r{lockName="app-exclusive-lock";instanceId=this.generateInstanceId();storageAvailable;lockLostSubject=new h;hasLockSubject=new f(!1);storage=null;lockLost$=this.lockLostSubject.asObservable();hasLock$=this.hasLockSubject.asObservable();hasLock=!1;constructor(){if(this.storageAvailable=this.tryInitializeStorage(),!this.storageAvailable)return;window.addEventListener("storage",this.handleStorageEvent),window.addEventListener("unload",this.handleUnload);let e=this.safeStorageRead();this.setHasLock(e===this.instanceId)}acquireLock(){return o(this,null,function*(){if(!this.storageAvailable)throw this.createAbortError("Lock storage is not available.");if(!this.hasLock)try{this.getStorage().setItem(this.lockName,this.instanceId),this.setHasLock(!0)}catch(e){throw this.createAbortError("Failed to acquire application lock.",e)}})}releaseLock(){return o(this,null,function*(){if(!(!this.storageAvailable||!this.hasLock))try{let e=this.getStorage();e.getItem(this.lockName)===this.instanceId&&e.removeItem(this.lockName),this.setHasLock(!1)}catch(e){throw this.createAbortError("Failed to release application lock.",e)}})}handleStorageEvent=e=>{if(e.key!==this.lockName)return;let t=e.newValue;this.hasLock&&t!==this.instanceId&&(this.setHasLock(!1),this.lockLostSubject.next())};handleUnload=()=>{this.hasLock&&this.releaseLock().catch(()=>{})};setHasLock(e){this.hasLock!==e&&(this.hasLock=e,this.hasLockSubject.next(e))}tryInitializeStorage(){if(typeof window>"u")return!1;try{let e=window.localStorage,t=`${this.lockName}-probe`;return e.setItem(t,"1"),e.removeItem(t),this.storage=e,!0}catch{return this.storage=null,!1}}getStorage(){if(!this.storage)throw this.createAbortError("Lock storage is not available.");return this.storage}safeStorageRead(){if(!this.storage)return null;try{return this.storage.getItem(this.lockName)}catch{return null}}generateInstanceId(){return typeof crypto<"u"&&"randomUUID"in crypto?crypto.randomUUID():`${Date.now()}-${Math.random().toString(16).slice(2)}`}createAbortError(e,t){try{let a=new DOMException(e,"AbortError");return t!==void 0&&(a.cause=t),a}catch{let a=new Error(e);return a.name="AbortError",t!==void 0&&(a.cause=t),a}}static \u0275fac=function(t){return new(t||r)};static \u0275prov=i({token:r,factory:r.\u0275fac,providedIn:"root"})};var v=class{fails;gameNumber;grid};var c=class{version=1;currentGameNumber;inProgressGames=[];constructor(e){e&&(this.currentGameNumber=e.gameNumber,e.grid&&this.inProgressGames.push({gameNumber:e.gameNumber,mistakes:e.fails,grid:e.grid,completed:!1}))}};var m=class{version=2;currentGameNumber;inProgressGames=[];constructor(e){e&&(this.currentGameNumber=e.currentGameNumber,e.inProgressGames&&(this.inProgressGames=e.inProgressGames.map(t=>({gameNumber:t.gameNumber,mistakes:t.mistakes,grid:t.grid,completed:t.completed,lastMoveTime:void 0,correctMoveHistory:[]}))))}};var l=class{version=3;currentGameNumber;inProgressGames=[];constructor(e){e&&(this.currentGameNumber=e.currentGameNumber,e.inProgressGames&&(this.inProgressGames=e.inProgressGames.map(t=>{let a=[];return t.correctMoveHistory&&t.lastMoveTime&&(a=t.correctMoveHistory.map(k=>({timestamp:t.lastMoveTime,correct:k}))),{gameNumber:t.gameNumber,grid:t.grid,completed:t.completed,moveHistory:a,timeSpent:void 0}})))}};var p=class r{constructor(e){this.idb=e}KEY="someNumbersSavedGame";init(){return o(this,null,function*(){yield this.idb.init()})}getAppData(){return o(this,null,function*(){return yield this.idb.get(this.KEY)})}saveWrapperToIdb(e){return o(this,null,function*(){yield this.idb.set(this.KEY,e)})}static \u0275fac=function(t){return new(t||r)(n(g))};static \u0275prov=i({token:r,factory:r.\u0275fac,providedIn:"root"})};var b=class r{service;constructor(e,t){this.service=new u(e,t)}static \u0275fac=function(t){return new(t||r)(n(p),n(d))};static \u0275prov=i({token:r,factory:r.\u0275fac,providedIn:"root"})},u=class{constructor(e,t){this.repo=e;this.lockService=t;this.checkForDuplicateVersionDtos()}gameVersions=[v,c,m,l];saveNoWait(e){if(!this.lockService.hasLock){console.log("No save lock, not saving");return}this.save(e).catch(t=>console.error(t))}save(e){return o(this,null,function*(){if(!this.lockService.hasLock){console.error("save ignored, no lock");return}let t={version:e.version,data:e};yield this.repo.saveWrapperToIdb(t)})}load(){return o(this,null,function*(){yield this.repo.init();let e=yield this.repo.getAppData();if(e)try{return yield this.migrate(e)}catch(t){console.warn("Error parsing saved data.",t);return}})}generateSaverDto(){return new this.gameVersions[this.gameVersions.length-1]}checkForDuplicateVersionDtos(){let e=new Set;for(let t of this.gameVersions){let a=new t;e.has(a.version)&&console.error(`Duplicate game state version found: ${a.version}`),e.add(a.version)}}migrate(e){return o(this,null,function*(){let t=e.data,a=this.generateSaverDto().version;for(let s=e.version+1;s<=a;s++)switch(s){case 1:t=new c(t);break;case 2:t=new m(t);break;case 3:t=new l(t);break;default:console.warn(`No migration path defined for version ${s}`);return}return yield this.save(t),t})}};export{d as a,b};
